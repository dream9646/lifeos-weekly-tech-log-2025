============================================================
C 基礎語法 × BMC 實務（W2 技能日整理）
============================================================

1) static const ssize_t（什麼時候用？）
------------------------------------------------------------
關鍵字:用途
內容:
  - static: 只在本檔案使用（封裝）
  - const: 不允許修改
  - ssize_t: 專門用來表示「write/read 回傳的 byte 數」

關鍵字:何時使用
內容:
  - 當你要定義「固定、不變、只在本檔案內使用的數字」
    例：buffer 長度、toggle 次數、delay 數值

例:
  static const ssize_t kBufSize = 128;

------------------------------------------------------------

2) fprintf / printf / perror 何時用？
------------------------------------------------------------
printf      → 輸出到 stdout（一般訊息）
fprintf     → 輸出到指定 FILE*（stderr → 錯誤訊息）
perror      → 自動印出 errno 對應字串（最簡潔）

實務：
  - 成功/一般資訊 → printf
  - 錯誤 → fprintf(stderr, ...)
  - 系統呼叫失敗 → perror("open");

------------------------------------------------------------

3) if (func() < 0) { ... } 的語法目的
------------------------------------------------------------
關鍵字:用途
內容:
  - 呼叫函式（例：GpioSetValue）
  - 若回傳值 < 0 → 表示錯誤 → 立即處理或 break

好處:
  - 讓每個步驟失敗時都能確保程式安全退出
  - 適合 BMC / Driver / SMBus 這種可能常失敗的場景

------------------------------------------------------------

4) argc / argv 用法（最小理解）
------------------------------------------------------------
argc = 參數個數  
argv = 字串陣列，每個參數都是 char*

例:
  ./gpio_led_toggle 37 20 200
  argv[1] = "37"
  argv[2] = "20"
  atoi(argv[1]) → 轉成 int

用法:
  - Command line 工具必備
  - BMC daemon 也常用 argv 分析設定

------------------------------------------------------------

5) return WriteOnce(...) 的用途
------------------------------------------------------------
關鍵字:語法意義
內容:
  - 你不需要多寫 if/else
  - 直接把被呼叫函式的回傳值「傳回上一層」

例:
  return WriteOnce("/sys/class/gpio/export", buf);

等於：
  int ret = WriteOnce(...);
  return ret;

------------------------------------------------------------

6) enum 與 typedef（何時用？）
------------------------------------------------------------
enum:
  - 定義一組「整數常數」
  - 適合：LED 狀態、風扇模式、錯誤碼

typedef:
  - 替某個型別重新取名字
  - 適合：struct、function pointer

例:
  enum LedColor { LED_RED, LED_GREEN };

  typedef struct {
    int gpio;
    int active_level;
  } LedInfo;

------------------------------------------------------------

7) strerror(errno)（錯誤字串）
------------------------------------------------------------
用途:
  - 取得最近一次系統呼叫失敗的錯誤描述

例:
  fprintf(stderr, "open failed: %s\n", strerror(errno));

BMC 實務:
  - 搭配 errno 可快速找出 SMBus / GPIO 為何失敗

------------------------------------------------------------

8) const char *str = value ? "1" : "0";
------------------------------------------------------------
關鍵字:三元運算子
內容:
  - value 為真 → 選 "1"
  - value 為假 → 選 "0"

用途:
  - 超常用於 GPIO / LED / on/off 轉字串

------------------------------------------------------------

9) return EXIT_SUCCESS / EXIT_FAILURE
------------------------------------------------------------
EXIT_SUCCESS = 0  
EXIT_FAILURE = 1  

用途:
  - 統一回傳成功/失敗
  - 容易被 shell script 捕捉（$?）

------------------------------------------------------------

10) #include <errno.h> <fcntl.h> <unistd.h> ...
------------------------------------------------------------
你不必背，只需知道：
  errno.h    → errno / strerror
  fcntl.h    → open() flag
  unistd.h   → read / write / close / usleep
  string.h   → strlen / strcpy / snprintf
  stdlib.h   → atoi / malloc / EXIT_*
  stdio.h    → printf / fprintf

原則:
  - 不需要背
  - 寫久了自然知道哪些功能在誰的 header

============================================================
============================================================
時間單位與 usleep / delay 心智圖
============================================================

1) 基本換算
------------------------------------------------------------
1 秒 (1 s)      = 1000 毫秒 (1000 ms)
1 毫秒 (1 ms)   = 1000 微秒 (1000 µs)
1 微秒 (1 µs)   = 1000 奈秒 (1000 ns)

常見數字感：
  - 1 s   = 一秒
  - 100 ms = 0.1 s（人眼明顯看到閃爍）
  - 10 ms  = 0.01 s（接近連續亮，較難分辨）
  - 1 ms   = 0.001 s（多用在通訊/精密時間）

------------------------------------------------------------
2) usleep()
------------------------------------------------------------
原型：
  int usleep(useconds_t usec);

參數單位：
  - 以「微秒 µs」為單位
  - 1 ms = 1000 µs → usleep(1 * 1000)

實務對照：
  - 想 delay 50 ms  → usleep(50 * 1000);
  - 想 delay 200 ms → usleep(200 * 1000);
  - 想 delay 100 ms → usleep(100 * 1000);

============================================================
3) 在這支 LED toggle 程式裡的應用
------------------------------------------------------------
目前你的程式：
  usleep(50);        → 大約 0.000050 秒 (50 µs)
  usleep(deley_ms);  → 直接用 argv[3] 當 µs

若你希望「參數代表 ms」：
  - 改名：int delay_ms;
  - 呼叫時：usleep(delay_ms * 1000);

例：
  ./gpio_led_toggle_mark 37 3 100   → 100 ms
  → 程式裡 usleep(delay_ms * 1000) = usleep(100000);

============================================================
4) 心法
------------------------------------------------------------
- 人眼可見的閃爍 → 範圍在 50 ms ~ 500 ms 之間。
- 小於 10 ms → 看起來幾乎長亮。
- 用 usleep 時，腦中先想「我要幾 ms」，再乘 1000 變成 µs。
============================================================
============================================================
API 設計（v2 GPIO Library）—— ASCII 版本
============================================================

關鍵字:API 是什麼？
內容:
  - API（Application Programming Interface）
    = 給「其他程式」呼叫的介面。
  - 在 C 裡 → 「函式 + 型態」組成 API。

------------------------------------------------------------
API 好的條件（四要素）
------------------------------------------------------------
1) 職責單一（Single Responsibility）
   - 一個函式只做一件事
   - gpio_export() 只做 export
   - gpio_set_direction() 只設定方向

2) 回傳值一致（Consistent Return Code）
   - 成功 → EXIT_SUCCESS
   - 失敗 → EXIT_FAILURE
   - 讓 caller 可以用 if(...) 判斷下一步

3) 命名清楚（Self-describing）
   - 一看就懂做什麼：
       gpio_export()
       gpio_unexport()
       gpio_write_value()
       gpio_set_direction()

4) API 隱藏細節（Encapsulation）
   - 使用者不需要知道 sysfs 的路徑
   - API 幫忙組好 "/sys/class/gpio/gpioN/value"
   - 使用者只要：gpio_write_value(37, 1);

------------------------------------------------------------
API 設計目的
------------------------------------------------------------
- 讓 main() 更乾淨
- 讓程式可維護、可測試、可擴充
- 讓 sysfs → /tmp/gpio → BMC driver 切換更容易
============================================================
============================================================
抽象化（Abstraction Layer）—— GPIO v2 設計
============================================================

關鍵字:抽象化是什麼？
內容:
  - 把「細節」藏起來，只留下「動作」。
  - 讓使用者不需要知道內部怎麼實作。

例子：
  調用者只需要：
    gpio_write_value(37, 1);

  但實際發生：
    open("/sys/class/gpio/gpio37/value")
    write("1")
    close(fd)

------------------------------------------------------------
為什麼需要抽象化？
------------------------------------------------------------
1) 減少重複程式碼（DRY 原則）
   - export/direction/value/unexport 90% 都是 open/write/close

2) 增加可讀性
   - main() 變成：
       gpio_export(gpio);
       gpio_set_direction(gpio, "out");
       gpio_write_value(gpio, 1);

3) 方便切換不同實作
   - sysfs → BMC driver ioctl
   - /tmp/gpio → 真實硬體
   - AST2500 → AST2600（不同 base path）

4) 建立層級（Layering）
   - 上層（app）控制邏輯
   - 下層（driver wrapper）負責細節

------------------------------------------------------------
抽象化在 BMC 工程的真實用處
------------------------------------------------------------
- LED Daemon 使用同一套 GPIO API，不需修改 sysfs 路徑
- 多板共用同一程式，只換 mapping table
- 測試時可用 /tmp/gpio 模擬，不動 main code

這就是系統工程師與「寫 script」最大的差別。
============================================================

