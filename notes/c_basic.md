============================================================
C 基礎語法 × BMC 實務（W2 技能日整理）
============================================================

1) static const ssize_t（什麼時候用？）
------------------------------------------------------------
關鍵字:用途
內容:
  - static: 只在本檔案使用（封裝）
  - const: 不允許修改
  - ssize_t: 專門用來表示「write/read 回傳的 byte 數」

關鍵字:何時使用
內容:
  - 當你要定義「固定、不變、只在本檔案內使用的數字」
    例：buffer 長度、toggle 次數、delay 數值

例:
  static const ssize_t kBufSize = 128;

------------------------------------------------------------

2) fprintf / printf / perror 何時用？
------------------------------------------------------------
printf      → 輸出到 stdout（一般訊息）
fprintf     → 輸出到指定 FILE*（stderr → 錯誤訊息）
perror      → 自動印出 errno 對應字串（最簡潔）

實務：
  - 成功/一般資訊 → printf
  - 錯誤 → fprintf(stderr, ...)
  - 系統呼叫失敗 → perror("open");

------------------------------------------------------------

3) if (func() < 0) { ... } 的語法目的
------------------------------------------------------------
關鍵字:用途
內容:
  - 呼叫函式（例：GpioSetValue）
  - 若回傳值 < 0 → 表示錯誤 → 立即處理或 break

好處:
  - 讓每個步驟失敗時都能確保程式安全退出
  - 適合 BMC / Driver / SMBus 這種可能常失敗的場景

------------------------------------------------------------

4) argc / argv 用法（最小理解）
------------------------------------------------------------
argc = 參數個數  
argv = 字串陣列，每個參數都是 char*

例:
  ./gpio_led_toggle 37 20 200
  argv[1] = "37"
  argv[2] = "20"
  atoi(argv[1]) → 轉成 int

用法:
  - Command line 工具必備
  - BMC daemon 也常用 argv 分析設定

------------------------------------------------------------

5) return WriteOnce(...) 的用途
------------------------------------------------------------
關鍵字:語法意義
內容:
  - 你不需要多寫 if/else
  - 直接把被呼叫函式的回傳值「傳回上一層」

例:
  return WriteOnce("/sys/class/gpio/export", buf);

等於：
  int ret = WriteOnce(...);
  return ret;

------------------------------------------------------------

6) enum 與 typedef（何時用？）
------------------------------------------------------------
enum:
  - 定義一組「整數常數」
  - 適合：LED 狀態、風扇模式、錯誤碼

typedef:
  - 替某個型別重新取名字
  - 適合：struct、function pointer

例:
  enum LedColor { LED_RED, LED_GREEN };

  typedef struct {
    int gpio;
    int active_level;
  } LedInfo;

------------------------------------------------------------

7) strerror(errno)（錯誤字串）
------------------------------------------------------------
用途:
  - 取得最近一次系統呼叫失敗的錯誤描述

例:
  fprintf(stderr, "open failed: %s\n", strerror(errno));

BMC 實務:
  - 搭配 errno 可快速找出 SMBus / GPIO 為何失敗

------------------------------------------------------------

8) const char *str = value ? "1" : "0";
------------------------------------------------------------
關鍵字:三元運算子
內容:
  - value 為真 → 選 "1"
  - value 為假 → 選 "0"

用途:
  - 超常用於 GPIO / LED / on/off 轉字串

------------------------------------------------------------

9) return EXIT_SUCCESS / EXIT_FAILURE
------------------------------------------------------------
EXIT_SUCCESS = 0  
EXIT_FAILURE = 1  

用途:
  - 統一回傳成功/失敗
  - 容易被 shell script 捕捉（$?）

------------------------------------------------------------

10) #include <errno.h> <fcntl.h> <unistd.h> ...
------------------------------------------------------------
你不必背，只需知道：
  errno.h    → errno / strerror
  fcntl.h    → open() flag
  unistd.h   → read / write / close / usleep
  string.h   → strlen / strcpy / snprintf
  stdlib.h   → atoi / malloc / EXIT_*
  stdio.h    → printf / fprintf

原則:
  - 不需要背
  - 寫久了自然知道哪些功能在誰的 header

============================================================
============================================================
時間單位與 usleep / delay 心智圖
============================================================

1) 基本換算
------------------------------------------------------------
1 秒 (1 s)      = 1000 毫秒 (1000 ms)
1 毫秒 (1 ms)   = 1000 微秒 (1000 µs)
1 微秒 (1 µs)   = 1000 奈秒 (1000 ns)

常見數字感：
  - 1 s   = 一秒
  - 100 ms = 0.1 s（人眼明顯看到閃爍）
  - 10 ms  = 0.01 s（接近連續亮，較難分辨）
  - 1 ms   = 0.001 s（多用在通訊/精密時間）

------------------------------------------------------------
2) usleep()
------------------------------------------------------------
原型：
  int usleep(useconds_t usec);

參數單位：
  - 以「微秒 µs」為單位
  - 1 ms = 1000 µs → usleep(1 * 1000)

實務對照：
  - 想 delay 50 ms  → usleep(50 * 1000);
  - 想 delay 200 ms → usleep(200 * 1000);
  - 想 delay 100 ms → usleep(100 * 1000);

============================================================
3) 在這支 LED toggle 程式裡的應用
------------------------------------------------------------
目前你的程式：
  usleep(50);        → 大約 0.000050 秒 (50 µs)
  usleep(deley_ms);  → 直接用 argv[3] 當 µs

若你希望「參數代表 ms」：
  - 改名：int delay_ms;
  - 呼叫時：usleep(delay_ms * 1000);

例：
  ./gpio_led_toggle_mark 37 3 100   → 100 ms
  → 程式裡 usleep(delay_ms * 1000) = usleep(100000);

============================================================
4) 心法
------------------------------------------------------------
- 人眼可見的閃爍 → 範圍在 50 ms ~ 500 ms 之間。
- 小於 10 ms → 看起來幾乎長亮。
- 用 usleep 時，腦中先想「我要幾 ms」，再乘 1000 變成 µs。
============================================================
