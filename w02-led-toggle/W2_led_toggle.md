============================================================
W2 LED Toggle 總綱（技能日）
============================================================

1) 任務定位
------------------------------------------------------------
W1 → 理解 sysfs  
W2 → 用 open/write/read 完成最小 LED toggle 程式  

目標：
  - 學會 open / write / read
  - 學會錯誤回報（errno）
  - 學會小型 CLI 程式（argc/argv）
  - 學會流程圖思維
  - 學會用 strace debug

------------------------------------------------------------

2) LED Toggle 最小流程
------------------------------------------------------------
  export GPIO
    ↓
  direction = out
    ↓
  value = 1
    ↓
  delay
    ↓
  value = 0
    ↓
  unexport

------------------------------------------------------------

3) BMC Daemon 的應用
------------------------------------------------------------
LED daemon：
  - 解析 config（GPIO 與 active_level）
  - 使用 struct table 管理多顆 LED
  - 用 open/write 控制亮滅
  - 用 timer thread 實現 blink

------------------------------------------------------------

4) 心法（參同契 × 孫子兵法）
------------------------------------------------------------
參同契：
  「一動一靜，陰陽互用」
  → LED toggle = on/off 交替，程序必須節律一致

兵法：
  「兵貴神速」
  → 寫程式時先跑通最小版本，不思考完美

------------------------------------------------------------

5) Debug Path
------------------------------------------------------------
若失敗：
  - 用 strace 看 open 是否成功
  - 用 ls 確認 sysfs 是否存在
  - 用 dmesg 看 kernel 錯誤
  - 檢查是否為 SIO 硬體（無 sysfs）

============================================================
============================================================
W2 LED Toggle 重點摘要
============================================================
- static const ssize_t → 用於固定、不變的數值（buffer、toggle 次數）
- fprintf/printf/perror → stdout/錯誤/errno 訊息
- argc/argv → CLI 工具的參數解析核心
- return WriteOnce(...) → 傳遞函式回傳值簡潔寫法
- enum / typedef → 整數常數組與型別命名
- strerror(errno) → 系統錯誤描述
- 三元運算子 → 簡潔轉換 "1"/"0"
- EXIT_SUCCESS / EXIT_FAILURE → 統一回傳碼
- sysfs header 不用背，用久自然熟
- pointer × 6 能力 + strace = BMC 工程師基本功

最重要：
  NCT6126D 是 SuperIO，不是 BMC GPIO，
  無法使用 /sys/class/gpio。
  W2 練習請使用 /tmp/gpio fake sysfs。

============================================================
============================================================
C 語法 / I/O 小抄（W2 版）
============================================================
- static function:
  只給本 .c 檔用的函式 → static
  避免撞名、隱藏實作、方便最佳化。

- const parameter:
  傳值 (int) → 加不加 const 功能一樣
  指標 (char *) → 用 const 保證不改字串內容

- printf / fprintf / perror:
  printf           → stdout（行緩衝、可被重導）
  fprintf(stderr)  → stderr（幾乎不緩衝、不易被重導）
  perror("msg")    → 在 stderr 印 "msg: 錯誤說明"

- argv:
  argv[0] = 程式名
  argv[1] = 第 1 個參數
  -> 陣列仍從 0 開始，只是 0 留給程式名。

- 沒 LED 怎麼驗證:
  1) 用 /tmp/gpio 假 sysfs，watch value 檔案內容
  2) 在迴圈加 printf debug
  3) 用 strace 檢查 open/write 是否成功
  4) 之後搬到真 BMC 板實測 LED
============================================================
============================================================
時間單位與 usleep / delay 心智圖
============================================================

1) 基本換算
------------------------------------------------------------
1 秒 (1 s)      = 1000 毫秒 (1000 ms)
1 毫秒 (1 ms)   = 1000 微秒 (1000 µs)
1 微秒 (1 µs)   = 1000 奈秒 (1000 ns)

常見數字感：
  - 1 s   = 一秒
  - 100 ms = 0.1 s（人眼明顯看到閃爍）
  - 10 ms  = 0.01 s（接近連續亮，較難分辨）
  - 1 ms   = 0.001 s（多用在通訊/精密時間）

------------------------------------------------------------
2) usleep()
------------------------------------------------------------
原型：
  int usleep(useconds_t usec);

參數單位：
  - 以「微秒 µs」為單位
  - 1 ms = 1000 µs → usleep(1 * 1000)

實務對照：
  - 想 delay 50 ms  → usleep(50 * 1000);
  - 想 delay 200 ms → usleep(200 * 1000);
  - 想 delay 100 ms → usleep(100 * 1000);

============================================================
3) 在這支 LED toggle 程式裡的應用
------------------------------------------------------------
目前你的程式：
  usleep(50);        → 大約 0.000050 秒 (50 µs)
  usleep(deley_ms);  → 直接用 argv[3] 當 µs

若你希望「參數代表 ms」：
  - 改名：int delay_ms;
  - 呼叫時：usleep(delay_ms * 1000);

例：
  ./gpio_led_toggle_mark 37 3 100   → 100 ms
  → 程式裡 usleep(delay_ms * 1000) = usleep(100000);

============================================================
4) 心法
------------------------------------------------------------
- 人眼可見的閃爍 → 範圍在 50 ms ~ 500 ms 之間。
- 小於 10 ms → 看起來幾乎長亮。
- 用 usleep 時，腦中先想「我要幾 ms」，再乘 1000 變成 µs。
============================================================
============================================================
W2：GPIO LED Toggle（user space / fake sysfs 版）
============================================================

1) 任務目標
------------------------------------------------------------
- 從 W1 的「讀 GPIO」進化到「寫 GPIO」
- 實作最小版 LED toggle C 程式：
  ./gpio_led_toggle [gpio] [count] [delay_ms]
- 熟悉：
  - open / write / close
  - usleep（時間單位）
  - errno + perror
  - strace 觀察系統呼叫

程式本體：
  - 放在 GitHub：w02-led-toggle/gpio_led_toggle_mark.c
  - 大頭四只記觀念與流程

------------------------------------------------------------
2) 核心流程（fake /tmp/gpio 版）
------------------------------------------------------------
1. 解析參數：
   - gpio      = argv[1]
   - count     = argv[2]
   - delay_ms  = argv[3] （實作時 * 1000 → us）

2. export：
   - path = "/tmp/gpio/export"
   - buf  = "N" (e.g. "37")
   - open(path, O_WRONLY)
   - write(fd, buf, strlen(buf))
   - close(fd)
   - usleep(50 ms) 等待節點建立

3. direction：
   - path = "/tmp/gpio/gpioN/direction"
   - buf  = "out"
   - open / write / close 一樣的 pattern

4. toggle 迴圈：
   for i in [0 .. count-1]:
     - 印 "Do count:i"
     - path = "/tmp/gpio/gpioN/value"
     - 寫 "1" → usleep(delay_ms)
     - 寫 "0" → usleep(delay_ms)

5. unexport：
   - path = "/tmp/gpio/unexport"
   - buf  = "N"
   - open / write / close

------------------------------------------------------------
3) 重要語法與概念
------------------------------------------------------------
- 程式組成：
  1) 資料型態（int / char[] / ssize_t）
  2) 變數（fd, gpio, count, delay_ms, path, buf）
  3) 函數（main + libc API：open/write/close/usleep）
  4) 控制流程（if 檢查 argc、for 迴圈）

- 時間單位：
  - 1 s  = 1000 ms
  - 1 ms = 1000 us
  - usleep(delay_ms * 1000) → 以 ms 為界面，比較直覺

- 錯誤處理：
  - open 失敗 → perror("open ..."); return EXIT_FAILURE;
  - write 長度不符 → perror("write ..."); close(fd); return EXIT_FAILURE;
  - 全程用 EXIT_SUCCESS / EXIT_FAILURE 作為回傳碼

- stdout / stderr：
  - printf(...)       → stdout（一般訊息）
  - perror("msg")     → stderr（錯誤訊息 + errno 字串）
  - 技術文建議：一般流程 print → printf，錯誤 → perror

------------------------------------------------------------
4) Debug 流程（strace）
------------------------------------------------------------
- 使用 strace 觀察系統呼叫：
  strace -f ./gpio_led_toggle_mark 37 3 100

- 檢查重點：
  - open("/tmp/gpio/export", O_WRONLY) 是否成功
  - write("37") / write("out") / write("1") / write("0") 的長度是否正確
  - 程式是否 exit(0)

- log 放置：
  - GitHub: w02-led-toggle/log_v1.md
  - 完整 strace：w02-led-toggle/log/strace_v1_full.txt

------------------------------------------------------------
5) 兵法 / 心法標註
------------------------------------------------------------
- 參同契：一陰一陽之謂道 → LED 亮/滅即陰陽交替
- 孫子兵法：兵貴神速 → 先讓最小版本跑通，再談重構與最佳化
- 技能心法：
  - v1 重點在「從 0 到 1」和「看得懂 strace」
  - v2 再把重複的 open/write 收斂成函式（抽象化）

============================================================
------------------------------------------------------------
gpio_export() 學習重點（v2）
------------------------------------------------------------
1) 函式職責單一：只負責 export，不處理 direction/value。
2) 回傳值一致：EXIT_SUCCESS / EXIT_FAILURE。
3) open / write / close 三段結構清楚、乾淨。
4) perror 用法正確：只能放固定字串。
5) 發現重複 pattern：後面可抽成 write_once()。
6) path 應由函式內組合，而不是由 caller 傳入。
------------------------------------------------------------

